---
description: [Database Security]: Prevents SQL Injection in C# applications by enforcing parameterized queries and ORM usage.
globs: ["**/*.cs"]
alwaysApply: true
---

# R: Risk First
- The security goal of this rule is to prevent SQL Injection vulnerabilities in C# applications by ensuring all database interactions use parameterized queries or a safe ORM (like Entity Framework Core).
- The risk being mitigated is that an attacker could manipulate SQL queries by injecting malicious code, leading to unauthorized data access, modification, or deletion.
- If this risk is not mitigated, the application's database and sensitive data become highly vulnerable to exploitation, potentially affecting all users and compromising the organization's security.

# A: Attached Constraints
- Never use string concatenation to build SQL queries.
- Avoid direct use of `SqlCommand` class without parameterization. Always prefer parameterized queries.
- Never log SQL queries with user-provided input included.
- Secure connectionstrings must not be hardcoded into code.
- Secure connection strings must not be written in logs.

// Examples of Violations:
//  - string query = "SELECT * FROM users WHERE username = '" + username + "'"; // Vulnerable to SQL injection
//  - SqlCommand cmd = new SqlCommand(query, connection); // Using SqlCommand without parameters

# I: Interpretative Framing
- If the prompt mentions "database access" or "SQL query," assume that secure database interaction is required, even if not explicitly stated.
- If the prompt suggests using an ORM, enforce using it with proper configurations (e.g., using Entity Framework Core with LINQ).
- LLM must use environment variables or secure vaults if required to create database credentials
- If no code is needed by the user, the LLM must not suggest the database credentials on that context.

// Ambiguity Handling:
// - If the prompt asks to get a user name to an unsafe query, make sure the LLM suggest a safe query, and ask if that query is intended.
// - If the developer gives a safe query with hardcoded information, make sure the code pulls information from environment configuration instead.

# L: Local Defaults
- The project uses Entity Framework Core (EF Core) ORM for database interactions.
- All database connections are configured with parameterized queries enabled.
- Logging is configured to prevent sensitive data from being written to logs.
- ConnectionStrings have a specific set of functions to create safe connection, environment file must be respected and no other form.

// Environment Configuration:
//  - ConnectionStrings:{"DefaultConnection":"Server=myServerAddress;Database=myDataBase;Uid=myUsername;Pwd=myPassword;"}

# G: Generative Path Checks
1. Identify if a database interaction is required.
2. If so, check if an ORM is already configured (EF Core).
   - If yes, use the ORM and LINQ to interact with the database in a safe and secure manner.
   - If no, use `SqlCommand` with parameterized queries, handling `SqlExceptions` appropriately.
3. Sanitize and validate input parameters before using them in database queries.
4. Ensure code is safe.

// Potential LLM-Introduced Vulnerabilities:
//  - Check for string concatenation in queries.
//  - Check the use of unescaped special characters.
//  - Check that sensitive information does not get saved on log functions.

# U: Uncertainty Disclosure
- If unsure about the correct way to use the ORM for a specific query, ask the developer for clarification.
- If the input data requires special handling, recommend seeking a security review.

// Examples of Questions:
//  - "Is the input data from a trusted source?"
//  - "Are you already using an ORM (Entity Framework Core)?"
// Do you need me to setup configuration for local enviroment using secure information (vaults, secrets)"

# A: Auditability
- Use comments to indicate where parameterized queries are being used: `// Using SqlCommand with parameters to prevent SQL injection`.
- Annotate entities with attributes (e.g., `[Table]`, `[Column]`) if using an ORM.

// Code Examples

// Safe query example
// https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand.parameters?view=netframework-4.8

# R+D: Revision + Dialogue
- The developer should review the generated code to ensure that parameterized queries or a secure ORM is used correctly.
- Use static analysis tools like SonarLint or Roslyn analyzers to detect potential SQL Injection vulnerabilities.
- Code must be tested and all functions should be validated.

// Explain Reasoning Command: Implement a command (e.g., /explain-sql-security) that the LLM can use to explain its SQL Injection prevention reasoning in more detail.

// Testing:
// - Verify the code is protected against common SQL injection vectors (e.g., ' OR 1=1; --).
// - Confirm that static analysis tools report no high-risk SQL Injection vulnerabilities.
