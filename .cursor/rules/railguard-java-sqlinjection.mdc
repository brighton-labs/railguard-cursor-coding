---
description: [Database Security]: Prevents SQL Injection in Java applications by enforcing parameterized queries and ORM usage.
globs: ["**/*.java"]
alwaysApply: true
---

# R: Risk First
- The security goal of this rule is to prevent SQL Injection vulnerabilities in Java applications by ensuring all database interactions use parameterized queries or a safe ORM.
- The risk being mitigated is that an attacker could manipulate SQL queries by injecting malicious code, leading to unauthorized data access, modification, or deletion.
- If this risk is not mitigated, the application's database and sensitive data become highly vulnerable to exploitation, potentially affecting all users and compromising the organization's security.

# A: Attached Constraints
- Never use string concatenation to build SQL queries.
- Avoid direct use of `Statement` class. Always prefer `PreparedStatement`.
- Never log SQL queries with user-provided input included.

// Examples of Violations:
//  - String query = "SELECT * FROM users WHERE username = '" + username + "'"; // Vulnerable to SQL injection
//  - Statement stmt = connection.createStatement();  // Using Statement class directly

# I: Interpretative Framing
- If the prompt mentions "database access" or "SQL query," assume that secure database interaction is required, even if not explicitly stated.
- If the prompt suggests using an ORM, enforce using it with proper configurations.
- If the database credentials are required, the LLM must not save hard coded credentials and environment variables should be used.

// Ambiguity Handling:
// - If the prompt asks to get a user name to an unsafe query, make sure the LLM suggest a safe query, and ask if that query is intended.
// - If the developer gives a safe query with hardcoded information, make sure the code pulls information from environment configuration instead.

# L: Local Defaults
- The project uses the Spring Data JPA ORM for database interactions.
- All database connections are configured with parameterized queries enabled.
- Logging is configured to prevent sensitive data from being written to logs.
- This project reads sensitive values from env files or vaults.

// Environment Configuration:
//  - SPRING_DATASOURCE_URL, SPRING_DATASOURCE_USERNAME, SPRING_DATASOURCE_PASSWORD

# G: Generative Path Checks
1. Identify if a database interaction is required.
2. If so, check if an ORM is already configured.
   - If yes, use the ORM to interact with the database in a secure manner.
   - If no, use `PreparedStatement` and parameterized queries, handling `SQLExceptions` appropriately.
3. Sanitize and validate input parameters before using them in database queries.
4. Ensure queries do not get logged in debug mode

// Potential LLM-Introduced Vulnerabilities:
//  - Check for string concatenation in queries.
//  - Check the use of unescaped special characters.

# U: Uncertainty Disclosure
- If unsure about the correct way to use the ORM for a specific query, ask the developer for clarification.
- If the input data requires special handling, recommend seeking a security review.
- If hardcoded info gets added, ask for variables and point to a documentation for environment config instead.

// Examples of Questions:
//  - "Is the input data from a trusted source?"
//  - "Are you already using an ORM?"

# A: Auditability
- Use comments to indicate where parameterized queries are being used: `// Using PreparedStatement to prevent SQL injection`.
- Annotate entities with `@Entity` if using an ORM.

// Code Examples
// @Entity annotation from JPA
// https://docs.oracle.com/javaee/6/api/javax/persistence/Entity.html

// Safe query example
// https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html

# R+D: Revision + Dialogue
- The developer should review the generated code to ensure that parameterized queries or a secure ORM is used correctly.
- Use static analysis tools like FindBugs or SonarQube to detect potential SQL Injection vulnerabilities.
- Do not blindly accept generated code. Make sure security standards are enforced by the code.

// Explain Reasoning Command: Implement a command (e.g., /explain-sql-security) that the LLM can use to explain its SQL Injection prevention reasoning in more detail.
// Testing:
// - Verify the code is protected against common SQL injection vectors (e.g., ' OR 1=1; --).
// - Confirm that static analysis tools report no high-risk SQL Injection vulnerabilities.
